<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a1a1a">
  <!-- Turbo/Hotwire Native: hide native navigation bar, we use our own header -->
  <meta name="turbo:native-navigation" content="hidden">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <title>Sprite Code</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #1a1a1a;
      --bg-secondary: #252525;
      --bg-tertiary: #2d2d2d;
      --text: #e5e5e5;
      --text-muted: #888;
      --accent: #d4a574;
      --user-bg: #3b3b3b;
      --assistant-bg: #252525;
      --border: #333;
      --input-bg: #2d2d2d;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
      --sidebar-width: 280px;
    }

    html {
      height: 100%;
      background: #1a1a1a;
      background: var(--bg);
    }

    body {
      height: 100%;
      min-height: 100dvh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
      font-size: 16px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* Layout */
    #app {
      position: fixed;
      inset: 0;
      display: flex;
      background: var(--bg);
    }

    /* Sidebar */
    #sidebar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: var(--sidebar-width);
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 100;
      display: flex;
      flex-direction: column;
      padding-top: var(--safe-top);
    }

    #sidebar.open {
      transform: translateX(0);
    }

    #sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #sidebar-header h2 {
      font-size: 17px;
      font-weight: 600;
    }

    #new-chat-btn {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: var(--accent);
      border: none;
      color: #1a1a1a;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #sessions-list {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .session-item {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .session-item:active {
      background: var(--bg-tertiary);
    }

    .session-item.active {
      background: var(--bg-tertiary);
      border-left: 3px solid var(--accent);
    }

    .session-name {
      font-weight: 500;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-preview {
      font-size: 13px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .session-time {
      font-size: 11px;
      color: var(--text-muted);
    }

    .session-delete {
      width: 36px;
      height: 36px;
      border: none;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .session-delete:active {
      background: #ef4444;
      color: white;
    }

    /* Overlay */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 99;
    }

    #overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    /* Main content */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding-top: var(--safe-top);
      min-width: 0;
      max-width: 100%;
      overflow: visible;
      background: var(--bg-secondary);
    }

    /* Header */
    header {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    #menu-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    header h1 {
      font-size: 17px;
      font-weight: 600;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      padding: 4px 8px;
      margin: -4px -8px;
      border-radius: 6px;
      transition: background 0.15s;
    }

    header h1:active {
      background: var(--bg-tertiary);
    }

    header h1.editing {
      background: var(--input-bg);
      cursor: text;
    }

    #title-input {
      font-size: 17px;
      font-weight: 600;
      background: transparent;
      border: none;
      color: var(--text);
      width: 100%;
      outline: none;
      padding: 0;
    }

    #regenerate-title-btn {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-right: 4px;
    }

    #regenerate-title-btn.visible {
      display: flex;
    }

    #regenerate-title-btn:active {
      background: var(--bg-tertiary);
    }

    #regenerate-title-btn.spinning svg {
      animation: spin 1s linear infinite;
    }

    #status {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    #status::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }

    #status.connected::before {
      background: #4ade80;
    }

    #status.error::before {
      background: #f87171;
    }

    /* Empty state */
    #empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 32px;
      text-align: center;
      color: var(--text-muted);
    }

    #empty-state h2 {
      font-size: 20px;
      color: var(--text);
      margin-bottom: 8px;
    }

    #empty-state p {
      margin-bottom: 24px;
    }

    #empty-state button {
      padding: 12px 24px;
      background: var(--accent);
      color: #1a1a1a;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
    }

    /* Messages area */
    #messages {
      flex: 1 1 auto;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 16px;
      -webkit-overflow-scrolling: touch;
      display: none;
      min-width: 0;
      max-width: 100%;
      min-height: 0;
    }

    #messages.active {
      display: block;
    }

    .message {
      margin-bottom: 16px;
      animation: fadeIn 0.2s ease;
      max-width: 100%;
      overflow: hidden;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message-header {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 4px;
      font-weight: 500;
    }

    .message-content {
      padding: 12px 14px;
      border-radius: 16px;
      max-width: 100%;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      overflow: hidden;
    }

    .message.user .message-content {
      background: var(--user-bg);
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: var(--assistant-bg);
      border: 1px solid var(--border);
      border-bottom-left-radius: 4px;
    }

    .message.system .message-content {
      background: transparent;
      color: var(--text-muted);
      font-size: 14px;
      text-align: center;
      padding: 8px;
    }

    /* Markdown content */
    .message-content p { margin-bottom: 8px; }
    .message-content p:last-child { margin-bottom: 0; }

    .message-content code {
      font-family: "SF Mono", Monaco, Consolas, monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message-content pre {
      margin: 8px 0;
      padding: 12px;
      background: #0d0d0d;
      border-radius: 8px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      max-width: 100%;
    }

    .message-content pre code {
      background: none;
      padding: 0;
      font-size: 13px;
      line-height: 1.4;
    }

    .message-content ul, .message-content ol { margin: 8px 0; padding-left: 24px; }
    .message-content li { margin-bottom: 4px; }
    .message-content a { color: var(--accent); text-decoration: none; }
    .message-content strong { font-weight: 600; }


    /* Tool indicator */
    .tool-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .tool-indicator .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Activity indicator - shows what Claude is doing */
    .activity-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      margin-bottom: 16px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .activity-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      flex-shrink: 0;
    }

    .activity-content {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .activity-action {
      font-size: 14px;
      color: var(--text);
      font-weight: 500;
    }

    .activity-detail {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-family: "SF Mono", Monaco, Consolas, monospace;
      margin-top: 2px;
    }

    /* Legacy thinking indicator (fallback) */
    .thinking-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      margin-bottom: 16px;
    }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      animation: bounce 1.4s ease-in-out infinite;
    }

    .thinking-dots span:nth-child(1) { animation-delay: 0s; }
    .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes bounce {
      0%, 80%, 100% { transform: translateY(0); opacity: 0.4; }
      40% { transform: translateY(-6px); opacity: 1; }
    }

    .thinking-text {
      font-size: 14px;
      color: var(--text-muted);
    }

    /* Input area */
    #input-area {
      flex: 0 0 auto;
      padding: 12px 16px;
      padding-bottom: 12px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: none;
      position: relative;
    }

    #input-area.active {
      display: block;
    }

    /* Extend input background to cover safe area and any gap below */
    #input-area::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      height: 200px; /* Large enough to cover any gap */
      background: var(--bg-secondary);
      pointer-events: none;
    }

    #input-wrapper {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    #input {
      flex: 1;
      min-height: 44px;
      max-height: 120px;
      padding: 10px 14px;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 22px;
      color: var(--text);
      font-size: 16px;
      font-family: inherit;
      line-height: 1.4;
      resize: none;
      outline: none;
      -webkit-appearance: none;
    }

    #input:focus { border-color: var(--accent); }
    #input::placeholder { color: var(--text-muted); }

    #send {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: #1a1a1a;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      -webkit-tap-highlight-color: transparent;
    }

    #send:disabled { opacity: 0.5; cursor: not-allowed; }
    #send:active:not(:disabled) { transform: scale(0.95); }

    /* Attach button */
    #attach-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      -webkit-tap-highlight-color: transparent;
    }
    #attach-btn:active { background: var(--bg-tertiary); }
    #attach-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Image preview */
    #image-preview {
      display: none;
      padding: 8px 16px;
      padding-bottom: 0;
    }
    #image-preview.has-image { display: block; }
    #image-preview-inner {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      max-width: 200px;
    }
    #image-preview img {
      width: 48px;
      height: 48px;
      object-fit: cover;
      border-radius: 8px;
    }
    #image-preview-name {
      font-size: 12px;
      color: var(--text-secondary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100px;
    }
    #remove-image {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--bg-secondary);
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
    }
    #remove-image:active { background: var(--border); }

    /* Settings button */
    #settings-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    /* Sprites Modal */
    #sprites-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 20px;
      padding-top: calc(20px + var(--safe-top));
      padding-bottom: calc(20px + var(--safe-bottom));
    }

    #sprites-modal.open {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      width: 100%;
      max-width: 400px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      font-size: 17px;
      font-weight: 600;
    }

    .modal-close {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: var(--bg-tertiary);
      border: none;
      color: var(--text);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    /* Sprites list */
    .sprites-list {
      margin-bottom: 16px;
    }

    .sprite-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .sprite-item:active {
      background: var(--bg);
    }

    .sprite-item.current {
      border: 2px solid var(--accent);
    }

    .sprite-info {
      flex: 1;
      min-width: 0;
    }

    .sprite-name {
      font-weight: 500;
      margin-bottom: 2px;
    }

    .sprite-address {
      font-size: 13px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sprite-delete {
      width: 28px;
      height: 28px;
      border: none;
      background: var(--bg);
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .sprite-delete:active {
      background: #ef4444;
      color: white;
    }

    .sprite-current-badge {
      font-size: 11px;
      color: var(--accent);
      background: rgba(212, 165, 116, 0.15);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Add sprite form */
    .add-sprite-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .add-sprite-form input {
      padding: 12px 14px;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 15px;
      outline: none;
    }

    .add-sprite-form input:focus {
      border-color: var(--accent);
    }

    .add-sprite-form input::placeholder {
      color: var(--text-muted);
    }

    .add-sprite-btn {
      padding: 12px;
      background: var(--accent);
      color: #1a1a1a;
      border: none;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
    }

    .add-sprite-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sprites-empty {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
      font-size: 14px;
    }

    /* Pull to refresh */
    #pull-indicator {
      position: fixed;
      top: var(--safe-top);
      left: 50%;
      transform: translateX(-50%) translateY(-60px);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 150;
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    #pull-indicator.visible {
      opacity: 1;
    }

    #pull-indicator.refreshing {
      transform: translateX(-50%) translateY(20px);
      opacity: 1;
    }

    #pull-indicator .pull-arrow {
      width: 20px;
      height: 20px;
      stroke: var(--accent);
      transition: transform 0.2s ease;
    }

    #pull-indicator.ready .pull-arrow {
      transform: rotate(180deg);
    }

    #pull-indicator .pull-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: none;
    }

    #pull-indicator.refreshing .pull-arrow {
      display: none;
    }

    #pull-indicator.refreshing .pull-spinner {
      display: block;
    }

    /* Waking overlay - shown while sprite is waking up */
    #waking-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    #waking-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #waking-overlay.removed {
      display: none;
    }

    .waking-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    .waking-text {
      color: var(--text);
      font-size: 16px;
      font-weight: 500;
    }

    .waking-subtext {
      color: var(--text-muted);
      font-size: 14px;
      margin-top: 8px;
    }

    #waking-log {
      margin-top: 16px;
      color: #666;
      font-size: 11px;
      font-family: monospace;
      max-height: 120px;
      overflow-y: auto;
      text-align: left;
      width: 100%;
      max-width: 280px;
    }

    .wlog-entry {
      margin: 3px 0;
    }

    /* Switching overlay - shown when switching to another sprite */
    #switching-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    #switching-overlay.visible {
      display: flex;
    }

    .switching-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    .switching-text {
      color: var(--text);
      font-size: 16px;
      font-weight: 500;
    }

    .switching-subtext {
      color: var(--text-muted);
      font-size: 14px;
      margin-top: 8px;
    }

    .sprite-emoji {
      filter: sepia(1) saturate(5) hue-rotate(70deg) brightness(1.1);
    }
  </style>
</head>
<body>
  <!-- Waking overlay - shown while sprite is waking from suspension -->
  <div id="waking-overlay">
    <div class="waking-spinner"></div>
    <div class="waking-text">Waking sprite...</div>
    <div class="waking-subtext">This may take a few seconds</div>
    <div id="waking-log"></div>
  </div>

  <!-- Switching overlay - shown when switching to another sprite -->
  <div id="switching-overlay">
    <div class="switching-spinner"></div>
    <div class="switching-text">Switching to sprite...</div>
    <div class="switching-subtext">Waking up the target sprite</div>
  </div>

  <!-- Pull to refresh indicator -->
  <div id="pull-indicator">
    <svg class="pull-arrow" viewBox="0 0 24 24" fill="none" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <polyline points="19 12 12 19 5 12"></polyline>
    </svg>
    <div class="pull-spinner"></div>
  </div>

  <div id="app">
    <!-- Sidebar -->
    <div id="sidebar">
      <div id="sidebar-header">
        <h2>Chats</h2>
        <button id="new-chat-btn" title="New Chat">+</button>
      </div>
      <div id="sessions-list"></div>
    </div>

    <div id="overlay"></div>

    <!-- Main -->
    <div id="main">
      <header>
        <button id="menu-btn">â˜°</button>
        <h1 id="chat-title">Sprite Code</h1>
        <button id="regenerate-title-btn" title="Regenerate title">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
          </svg>
        </button>
        <div id="status">Disconnected</div>
        <button id="settings-btn" title="Manage Sprites">âš™</button>
      </header>

      <div id="empty-state">
        <h2>Welcome to Sprite Code</h2>
        <p>Start a new chat to begin coding</p>
        <button id="start-chat-btn">New Chat</button>
      </div>

      <div id="messages"></div>

      <div id="input-area">
        <div id="image-preview">
          <div id="image-preview-inner">
            <img id="image-preview-img" src="" alt="Preview">
            <span id="image-preview-name"></span>
            <button id="remove-image">Ã—</button>
          </div>
        </div>
        <div id="input-wrapper">
          <button id="attach-btn" title="Attach image">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
            </svg>
          </button>
          <input type="file" id="file-input" accept="image/*" hidden>
          <textarea id="input" placeholder="Message Claude..." rows="1" enterkeyhint="send" autocomplete="off" autocorrect="off" autocapitalize="sentences" spellcheck="false"></textarea>
          <button id="send" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="22" y1="2" x2="11" y2="13"></line>
              <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Sprites Modal -->
  <div id="sprites-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Manage Sprites</h2>
        <button class="modal-close" id="close-sprites-modal">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="sprites-list" id="sprites-list"></div>
        <div class="add-sprite-form">
          <input type="text" id="sprite-name-input" placeholder="Sprite name (e.g., Work Sprite)">
          <input type="text" id="sprite-address-input" placeholder="Tailscale IP (e.g., 100.64.1.2)">
          <button class="add-sprite-btn" id="add-sprite-btn">Add Sprite</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
  <script>
    // Hotwire Native Bridge - request to hide native navigation
    (function() {
      // Check if we're in a Hotwire Native context
      if (window.Turbo && window.Turbo.navigator && window.Turbo.navigator.adapter) {
        // Try to hide native navigation bar
        try {
          window.Turbo.navigator.adapter.visitProposedToLocation = function(location, options) {
            options.action = options.action || 'advance';
            return true;
          };
        } catch (e) {}
      }

      // Alternative: Use Strada bridge if available
      if (window.bridge) {
        try {
          window.bridge.send('hideNavBar');
        } catch (e) {}
      }
    })();
  </script>
  <script>
    // Register service worker for offline shell and cached config
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then((reg) => console.log('Service worker registered'))
        .catch((err) => console.log('Service worker registration failed:', err));
    }

    // Elements
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('overlay');
    const menuBtn = document.getElementById('menu-btn');
    const newChatBtn = document.getElementById('new-chat-btn');
    const startChatBtn = document.getElementById('start-chat-btn');
    const sessionsList = document.getElementById('sessions-list');
    const chatTitle = document.getElementById('chat-title');
    const emptyState = document.getElementById('empty-state');
    const messagesEl = document.getElementById('messages');
    const inputArea = document.getElementById('input-area');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const statusEl = document.getElementById('status');
    const settingsBtn = document.getElementById('settings-btn');
    const regenerateTitleBtn = document.getElementById('regenerate-title-btn');
    const attachBtn = document.getElementById('attach-btn');
    const fileInput = document.getElementById('file-input');
    const imagePreview = document.getElementById('image-preview');
    const imagePreviewImg = document.getElementById('image-preview-img');
    const imagePreviewName = document.getElementById('image-preview-name');
    const removeImageBtn = document.getElementById('remove-image');
    const spritesModal = document.getElementById('sprites-modal');
    const closeSpritesModal = document.getElementById('close-sprites-modal');
    const spritesList = document.getElementById('sprites-list');
    const spriteNameInput = document.getElementById('sprite-name-input');
    const spriteAddressInput = document.getElementById('sprite-address-input');
    const addSpriteBtn = document.getElementById('add-sprite-btn');
    const pullIndicator = document.getElementById('pull-indicator');
    const wakingOverlay = document.getElementById('waking-overlay');
    const switchingOverlay = document.getElementById('switching-overlay');

    // State
    let sessions = [];
    let currentSession = null;
    let ws = null;
    let keepaliveWs = null;
    let currentAssistantMessage = null;
    let assistantContent = '';
    let sprites = [];
    let pendingImage = null; // { id, filename, mediaType, url, localUrl }
    let isEditingTitle = false;
    let messageCountSinceLastTitleUpdate = 0;
    let pendingUserMessage = false; // True while processing incoming user_message

    // Activity indicator state
    let currentToolName = null;
    let currentToolInput = '';

    // Tool name to human-readable action mapping
    const toolActions = {
      'Read': { action: 'Reading', getDetail: (input) => input?.file_path },
      'Write': { action: 'Writing', getDetail: (input) => input?.file_path },
      'Edit': { action: 'Editing', getDetail: (input) => input?.file_path },
      'Bash': { action: 'Running', getDetail: (input) => input?.command?.slice(0, 60) },
      'Grep': { action: 'Searching', getDetail: (input) => input?.pattern ? `"${input.pattern}"` : null },
      'Glob': { action: 'Finding files', getDetail: (input) => input?.pattern },
      'Task': { action: 'Working on subtask', getDetail: (input) => input?.description },
      'WebFetch': { action: 'Fetching', getDetail: (input) => input?.url },
      'WebSearch': { action: 'Searching web', getDetail: (input) => input?.query },
      'LSP': { action: 'Analyzing code', getDetail: (input) => input?.operation },
      'TodoWrite': { action: 'Updating tasks', getDetail: () => null },
      'AskUserQuestion': { action: 'Asking question', getDetail: () => null },
      'NotebookEdit': { action: 'Editing notebook', getDetail: (input) => input?.notebook_path },
    };

    function getToolAction(toolName) {
      return toolActions[toolName] || { action: `Using ${toolName}`, getDetail: () => null };
    }

    function truncatePath(path, maxLen = 40) {
      if (!path || path.length <= maxLen) return path;
      // Show the end of the path (most relevant part)
      return '...' + path.slice(-(maxLen - 3));
    }

    // Keepalive WebSocket - keeps sprite awake while app is open
    function connectKeepalive() {
      if (keepaliveWs && keepaliveWs.readyState === WebSocket.OPEN) return;

      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      keepaliveWs = new WebSocket(`${protocol}//${location.host}/ws/keepalive`);

      keepaliveWs.onopen = () => {
        console.log('Keepalive connected - sprite will stay awake');
      };

      keepaliveWs.onclose = () => {
        console.log('Keepalive disconnected');
        // Reconnect after a short delay
        setTimeout(connectKeepalive, 2000);
      };

      keepaliveWs.onerror = () => {
        console.log('Keepalive error');
      };
    }

    // Keepalive will be connected after sprite wakes up in init()

    // Public URL keepalive - pings the public URL every 30 seconds to keep sprite awake
    let spritePublicUrl = null;
    let spriteName = 'Sprite Code'; // Default, will be updated from publicUrl
    let publicKeepaliveInterval = null;

    // Extract and sanitize hostname from public URL
    function getSpriteNameFromUrl(url) {
      if (!url) return null;
      try {
        const hostname = new URL(url).hostname;
        // Extract subdomain (first part before first dot)
        const subdomain = hostname.split('.')[0];
        // Sanitize: only allow alphanumeric, hyphens, underscores
        const sanitized = subdomain.replace(/[^a-zA-Z0-9\-_]/g, '');
        return sanitized || null;
      } catch {
        return null;
      }
    }

    // Update displayed sprite name
    function updateSpriteName(name) {
      spriteName = name || 'Sprite Code';
      const emojiHtml = '<span class="sprite-emoji">ðŸ‘¾</span>';
      const displayHtml = `${escapeHtml(spriteName)} ${emojiHtml}`;
      // Update header title if showing empty state
      if (emptyState.style.display !== 'none') {
        chatTitle.innerHTML = displayHtml;
      }
      // Update welcome message
      const welcomeH2 = emptyState.querySelector('h2');
      if (welcomeH2) {
        welcomeH2.innerHTML = `Welcome to ${displayHtml}`;
      }
      // Update page title
      document.title = spriteName;
    }

    // Get cached config from service worker
    function getCachedConfig() {
      return new Promise((resolve) => {
        if (!navigator.serviceWorker?.controller) {
          resolve(null);
          return;
        }

        const timeout = setTimeout(() => resolve(null), 1000);

        const handler = (event) => {
          if (event.data?.type === 'CACHED_CONFIG') {
            clearTimeout(timeout);
            navigator.serviceWorker.removeEventListener('message', handler);
            resolve(event.data.config);
          }
        };

        navigator.serviceWorker.addEventListener('message', handler);
        navigator.serviceWorker.controller.postMessage({ type: 'GET_CACHED_CONFIG' });
      });
    }

    // Cache config in service worker
    function cacheConfig(config) {
      if (navigator.serviceWorker?.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'CACHE_CONFIG', config });
      }
    }

    // Hide the waking overlay with animation
    function hideWakingOverlay() {
      wakingOverlay.classList.add('hidden');
      setTimeout(() => wakingOverlay.classList.add('removed'), 300);
    }

    // Log to the waking overlay for debugging
    const wakingLog = document.getElementById('waking-log');
    function wakeLog(msg) {
      console.log('[wake]', msg);
      if (wakingLog) {
        const entry = document.createElement('div');
        entry.className = 'wlog-entry';
        entry.textContent = msg;
        wakingLog.appendChild(entry);
        wakingLog.scrollTop = wakingLog.scrollHeight;
      }
    }

    // Try to fetch config from sprite, with retries
    async function fetchConfigWithRetry(maxRetries = 10, delay = 1000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 5000);

          const res = await fetch(`/api/config?_t=${Date.now()}`, { signal: controller.signal });
          clearTimeout(timeout);

          if (res.ok) {
            return await res.json();
          }
        } catch (err) {
          console.log(`Config fetch attempt ${i + 1}/${maxRetries} failed, retrying...`);
        }

        if (i < maxRetries - 1) {
          await new Promise(r => setTimeout(r, delay));
        }
      }
      return null;
    }

    // Wake up sprite using cached or fresh public URL
    async function wakeUpSprite() {
      wakeLog('Starting wake-up...');
      wakeLog('SW controller: ' + (navigator.serviceWorker?.controller ? 'yes' : 'no'));

      // First, try to get cached config from service worker
      const cachedConfig = await getCachedConfig();
      wakeLog('Cached config: ' + (cachedConfig ? JSON.stringify(cachedConfig) : 'none'));

      if (cachedConfig?.publicUrl) {
        spritePublicUrl = cachedConfig.publicUrl;
        updateSpriteName(getSpriteNameFromUrl(spritePublicUrl));
        wakeLog('Pinging: ' + spritePublicUrl);

        // Ping the public URL to wake the sprite
        try {
          await fetch(spritePublicUrl, { mode: 'no-cors', cache: 'no-store' });
          wakeLog('Ping sent OK');
        } catch (err) {
          wakeLog('Ping error: ' + err.message);
        }

        // Wait for sprite to actually respond
        wakeLog('Waiting for sprite...');
        const config = await fetchConfigWithRetry();
        if (config) {
          wakeLog('Sprite responded!');
          spritePublicUrl = config.publicUrl;
          updateSpriteName(getSpriteNameFromUrl(spritePublicUrl));
          cacheConfig(config);
          startPublicKeepalive();
          return true;
        }
        wakeLog('Sprite did not respond');
      }

      // No cached config or wake failed - try fetching directly
      // (sprite might already be awake)
      wakeLog('Trying direct connection...');
      try {
        const config = await fetchConfigWithRetry(3, 500);
        if (config?.publicUrl) {
          wakeLog('Direct connection OK');
          spritePublicUrl = config.publicUrl;
          updateSpriteName(getSpriteNameFromUrl(spritePublicUrl));
          cacheConfig(config);
          startPublicKeepalive();
          return true;
        }
      } catch (err) {
        wakeLog('Direct failed: ' + err.message);
      }

      wakeLog('Could not reach sprite');
      return false;
    }

    function startPublicKeepalive() {
      if (!spritePublicUrl || publicKeepaliveInterval) return;

      // Ping every 30 seconds
      publicKeepaliveInterval = setInterval(pingPublicUrl, 30000);
    }

    function pingPublicUrl() {
      if (!spritePublicUrl) return;

      fetch(spritePublicUrl, { mode: 'no-cors', cache: 'no-store' })
        .then(() => console.log('Public keepalive ping sent'))
        .catch(() => console.log('Public keepalive ping failed'));
    }

    // Configure marked
    marked.setOptions({
      highlight: (code, lang) => {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        }
        return hljs.highlightAuto(code).value;
      },
      breaks: true,
    });

    // Sidebar toggle
    function openSidebar() {
      sidebar.classList.add('open');
      overlay.classList.add('visible');
    }

    function closeSidebar() {
      sidebar.classList.remove('open');
      overlay.classList.remove('visible');
    }

    menuBtn.addEventListener('click', openSidebar);
    overlay.addEventListener('click', closeSidebar);

    // Swipe to close sidebar
    let sidebarTouchStartX = 0;
    let sidebarTouchCurrentX = 0;
    let isSidebarSwiping = false;

    sidebar.addEventListener('touchstart', (e) => {
      if (!sidebar.classList.contains('open')) return;
      sidebarTouchStartX = e.touches[0].clientX;
      sidebarTouchCurrentX = sidebarTouchStartX;
      isSidebarSwiping = true;
      sidebar.style.transition = 'none';
    }, { passive: true });

    sidebar.addEventListener('touchmove', (e) => {
      if (!isSidebarSwiping) return;
      sidebarTouchCurrentX = e.touches[0].clientX;
      const diff = sidebarTouchCurrentX - sidebarTouchStartX;
      if (diff < 0) {
        sidebar.style.transform = `translateX(${diff}px)`;
        overlay.style.opacity = Math.max(0, 1 + diff / 280);
      }
    }, { passive: true });

    sidebar.addEventListener('touchend', () => {
      if (!isSidebarSwiping) return;
      isSidebarSwiping = false;
      sidebar.style.transition = '';
      sidebar.style.transform = '';
      overlay.style.opacity = '';

      const diff = sidebarTouchCurrentX - sidebarTouchStartX;
      if (diff < -80) {
        closeSidebar();
      }
    });

    // Sessions API
    async function loadSessions() {
      const res = await fetch('/api/sessions');
      sessions = await res.json();
      renderSessionsList();
      return sessions;
    }

    async function createSession(name) {
      const res = await fetch('/api/sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name }),
      });
      const session = await res.json();
      sessions.unshift(session);
      renderSessionsList();
      selectSession(session);
      closeSidebar();
    }

    async function deleteSession(id, e) {
      e.stopPropagation();
      e.preventDefault();

      await fetch(`/api/sessions/${id}`, { method: 'DELETE' });
      sessions = sessions.filter(s => s.id !== id);
      if (currentSession?.id === id) {
        currentSession = null;
        disconnectWs();
        showEmptyState();
      }
      renderSessionsList();
    }

    function renderSessionsList() {
      sessionsList.innerHTML = sessions.map(s => `
        <div class="session-item ${currentSession?.id === s.id ? 'active' : ''}" data-id="${s.id}">
          <div class="session-name">
            <span>${escapeHtml(s.name)}</span>
            <button class="session-delete" onclick="deleteSession('${s.id}', event)">Ã—</button>
          </div>
          <div class="session-preview">${escapeHtml(s.lastMessage || 'No messages yet')}</div>
          <div class="session-time">${formatTime(s.lastMessageAt)}</div>
        </div>
      `).join('');

      sessionsList.querySelectorAll('.session-item').forEach(el => {
        el.addEventListener('click', () => {
          const session = sessions.find(s => s.id === el.dataset.id);
          if (session) {
            selectSession(session);
            closeSidebar();
          }
        });
      });
    }

    function formatTime(ts) {
      const d = new Date(ts);
      const now = new Date();
      if (d.toDateString() === now.toDateString()) {
        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      return d.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }

    function selectSession(session) {
      currentSession = session;
      chatTitle.textContent = session.name;
      emptyState.style.display = 'none';
      messagesEl.classList.add('active');
      inputArea.classList.add('active');
      messagesEl.innerHTML = '';
      renderSessionsList();
      connectWs(session.id);
      regenerateTitleBtn.classList.add('visible');
      messageCountSinceLastTitleUpdate = 0;
    }

    function showEmptyState() {
      const emojiHtml = '<span class="sprite-emoji">ðŸ‘¾</span>';
      chatTitle.innerHTML = `${escapeHtml(spriteName)} ${emojiHtml}`;
      emptyState.style.display = 'flex';
      messagesEl.classList.remove('active');
      inputArea.classList.remove('active');
      statusEl.textContent = 'Disconnected';
      statusEl.className = '';
      regenerateTitleBtn.classList.remove('visible');
    }

    // WebSocket
    let currentWsSessionId = null;

    function connectWs(sessionId) {
      // Clear any pending reconnect
      if (wsReconnectTimeout) {
        clearTimeout(wsReconnectTimeout);
        wsReconnectTimeout = null;
      }

      // Close old connection without triggering reconnect for it
      if (ws) {
        const oldWs = ws;
        ws = null;
        oldWs.onclose = null; // Prevent onclose from firing
        oldWs.close();
      }

      currentWsSessionId = sessionId;
      intentionalDisconnect = false;
      currentAssistantMessage = null;
      assistantContent = '';

      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws?session=${sessionId}`);

      ws.onopen = () => {
        statusEl.textContent = 'Connected';
        statusEl.className = 'connected';
        sendBtn.disabled = false;
        wsReconnectAttempts = 0; // Reset on successful connection
      };

      ws.onclose = () => {
        statusEl.textContent = 'Disconnected';
        statusEl.className = 'error';
        sendBtn.disabled = true;
        scheduleReconnect();
      };

      ws.onerror = () => {
        statusEl.textContent = 'Error';
        statusEl.className = 'error';
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleMessage(msg);
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };
    }

    let wsReconnectTimeout = null;
    let wsReconnectAttempts = 0;
    let intentionalDisconnect = false;

    function disconnectWs() {
      intentionalDisconnect = true;
      currentWsSessionId = null;
      if (wsReconnectTimeout) {
        clearTimeout(wsReconnectTimeout);
        wsReconnectTimeout = null;
      }
      if (ws) {
        ws.onclose = null; // Prevent onclose from triggering reconnect
        ws.close();
        ws = null;
      }
      currentAssistantMessage = null;
      assistantContent = '';
      wsReconnectAttempts = 0;
    }

    function scheduleReconnect() {
      if (intentionalDisconnect || !currentWsSessionId) return;

      // Exponential backoff: 1s, 2s, 4s, 8s, max 30s
      const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 30000);
      wsReconnectAttempts++;

      statusEl.textContent = `Reconnecting in ${Math.round(delay/1000)}s...`;
      statusEl.className = 'error';

      const sessionToReconnect = currentWsSessionId;
      wsReconnectTimeout = setTimeout(() => {
        // Only reconnect if we're still trying to connect to the same session
        if (currentWsSessionId === sessionToReconnect && !intentionalDisconnect) {
          statusEl.textContent = 'Reconnecting...';
          connectWs(sessionToReconnect);
        }
      }, delay);
    }

    function handleMessage(msg) {
      switch (msg.type) {
        case 'system':
          if (msg.message && !msg.message.includes('Connected')) {
            addSystemMessage(msg.message);
          }
          break;

        case 'history':
          // Render stored message history - clear first to avoid duplicates
          if (msg.messages && Array.isArray(msg.messages)) {
            messagesEl.innerHTML = '';
            currentAssistantMessage = null;
            assistantContent = '';
            for (const m of msg.messages) {
              if (m.role === 'user') {
                // Build image URL if message has an attached image
                const imageUrl = m.image ? `/api/uploads/${currentSession.id}/${m.image.filename}` : null;
                addUserMessage(m.content, imageUrl);
              } else if (m.role === 'assistant') {
                addStoredAssistantMessage(m.content);
              }
            }
          }
          break;

        case 'refresh_sessions':
          // Refresh sidebar and update current chat title if changed
          loadSessions().then(() => {
            if (currentSession) {
              const updated = sessions.find(s => s.id === currentSession.id);
              if (updated && updated.name !== currentSession.name) {
                currentSession.name = updated.name;
                chatTitle.textContent = updated.name;
              }
            }
          });
          break;

        case 'processing':
          // Claude is still working (reconnected to running process)
          if (msg.isProcessing) {
            showThinkingIndicator();
          }
          break;

        case 'user_message':
          // Another client sent a message - display it and show thinking
          // Set flag to ensure user message is rendered before assistant starts
          pendingUserMessage = true;
          if (msg.message) {
            const m = msg.message;
            const imageUrl = m.image ? `/api/uploads/${currentSession.id}/${m.image.filename}` : null;
            addUserMessage(m.content, imageUrl);
            showThinkingIndicator();
          }
          // Small delay to ensure DOM update completes
          requestAnimationFrame(() => {
            pendingUserMessage = false;
          });
          break;

        case 'assistant':
          // Wait for any pending user message to render first
          if (pendingUserMessage) {
            requestAnimationFrame(() => {
              if (msg.message?.content) {
                handleAssistantContent(msg.message.content);
              }
              if (msg.stop_reason) {
                finalizeAssistantMessage();
              }
            });
          } else {
            if (msg.message?.content) {
              handleAssistantContent(msg.message.content);
            }
            if (msg.stop_reason) {
              finalizeAssistantMessage();
            }
          }
          break;

        case 'content_block_start':
          // Wait for any pending user message to render first
          if (pendingUserMessage) {
            requestAnimationFrame(() => {
              if (msg.content_block?.type === 'text') {
                startAssistantMessage();
              } else if (msg.content_block?.type === 'tool_use') {
                addToolIndicator(msg.content_block.name);
              }
            });
          } else {
            if (msg.content_block?.type === 'text') {
              startAssistantMessage();
            } else if (msg.content_block?.type === 'tool_use') {
              addToolIndicator(msg.content_block.name);
            }
          }
          break;

        case 'content_block_delta':
          // Wait for any pending user message to render first
          if (pendingUserMessage) {
            requestAnimationFrame(() => {
              handleContentBlockDelta(msg);
            });
          } else {
            handleContentBlockDelta(msg);
          }
          break;

        case 'message_stop':
          finalizeAssistantMessage();
          break;

        case 'result':
          // Tool finished - remove indicator regardless of result content
          removeToolIndicator();
          break;
      }
      scrollToBottom();
    }

    function handleAssistantContent(content) {
      if (Array.isArray(content)) {
        for (const block of content) {
          if (block.type === 'text') {
            startAssistantMessage();
            appendAssistantText(block.text);
          } else if (block.type === 'tool_use') {
            addToolIndicator(block.name, block.input);
          }
        }
      } else if (typeof content === 'string') {
        startAssistantMessage();
        appendAssistantText(content);
      }
    }

    function handleContentBlockDelta(msg) {
      if (msg.delta?.type === 'text_delta') {
        appendAssistantText(msg.delta.text);
      } else if (msg.delta?.type === 'input_json_delta' && currentToolName) {
        // Accumulate tool input JSON
        currentToolInput += msg.delta.partial_json || '';

        // Try to parse and update indicator with details
        try {
          const parsed = JSON.parse(currentToolInput);
          const toolInfo = getToolAction(currentToolName);
          const detail = toolInfo.getDetail(parsed);
          if (detail) {
            updateActivityIndicator(detail);
          }
        } catch {
          // JSON not complete yet, that's fine
        }
      }
    }

    function startAssistantMessage() {
      if (!currentAssistantMessage) {
        removeThinkingIndicator();
        removeToolIndicator();
        currentAssistantMessage = document.createElement('div');
        currentAssistantMessage.className = 'message assistant';
        currentAssistantMessage.innerHTML = `
          <div class="message-header">Claude</div>
          <div class="message-content streaming"></div>
        `;
        messagesEl.appendChild(currentAssistantMessage);
        assistantContent = '';
      }
    }

    function appendAssistantText(text) {
      if (!currentAssistantMessage) startAssistantMessage();
      assistantContent += text;
      const contentEl = currentAssistantMessage.querySelector('.message-content');
      contentEl.innerHTML = marked.parse(assistantContent);
      contentEl.classList.add('streaming');
      scrollToBottom();
    }

    function finalizeAssistantMessage() {
      removeToolIndicator();
      if (currentAssistantMessage) {
        const contentEl = currentAssistantMessage.querySelector('.message-content');
        contentEl.classList.remove('streaming');
        contentEl.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
        currentAssistantMessage = null;
        assistantContent = '';
        // Track for auto title regeneration
        maybeAutoRegenerateTitle();
      }
    }

    function addUserMessage(text, imageUrl = null) {
      const msg = document.createElement('div');
      msg.className = 'message user';
      let imageHtml = '';
      if (imageUrl) {
        imageHtml = `<img src="${imageUrl}" class="message-image" style="max-width: 200px; max-height: 200px; border-radius: 8px; margin-bottom: 8px; display: block;">`;
      }
      msg.innerHTML = `
        <div class="message-header">You</div>
        <div class="message-content">${imageHtml}${text ? escapeHtml(text) : ''}</div>
      `;
      messagesEl.appendChild(msg);
      scrollToBottom();
    }

    function addStoredAssistantMessage(text) {
      const msg = document.createElement('div');
      msg.className = 'message assistant';
      const contentEl = document.createElement('div');
      contentEl.className = 'message-content';
      contentEl.innerHTML = marked.parse(text);
      contentEl.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
      msg.innerHTML = `<div class="message-header">Claude</div>`;
      msg.appendChild(contentEl);
      messagesEl.appendChild(msg);
      scrollToBottom();
    }

    function addSystemMessage(text) {
      const msg = document.createElement('div');
      msg.className = 'message system';
      msg.innerHTML = `<div class="message-content">${escapeHtml(text)}</div>`;
      messagesEl.appendChild(msg);
      scrollToBottom();
    }

    function showActivityIndicator(action, detail = null) {
      removeActivityIndicator();
      removeThinkingIndicator();
      const indicator = document.createElement('div');
      indicator.className = 'activity-indicator';
      indicator.innerHTML = `
        <div class="activity-spinner"></div>
        <div class="activity-content">
          <div class="activity-action">${escapeHtml(action)}...</div>
          ${detail ? `<div class="activity-detail">${escapeHtml(truncatePath(detail))}</div>` : ''}
        </div>
      `;
      messagesEl.appendChild(indicator);
      scrollToBottom();
    }

    function updateActivityIndicator(detail) {
      const indicator = messagesEl.querySelector('.activity-indicator');
      if (indicator) {
        let detailEl = indicator.querySelector('.activity-detail');
        if (detail) {
          if (!detailEl) {
            detailEl = document.createElement('div');
            detailEl.className = 'activity-detail';
            indicator.querySelector('.activity-content').appendChild(detailEl);
          }
          detailEl.textContent = truncatePath(detail);
        }
      }
    }

    function removeActivityIndicator() {
      const indicators = messagesEl.querySelectorAll('.activity-indicator');
      indicators.forEach(ind => ind.remove());
      // Reset tool state
      currentToolName = null;
      currentToolInput = '';
    }

    function addToolIndicator(toolName, toolInput = null) {
      finalizeAssistantMessage();
      currentToolName = toolName;
      currentToolInput = '';

      const toolInfo = getToolAction(toolName);
      let detail = null;

      if (toolInput) {
        try {
          const parsed = typeof toolInput === 'string' ? JSON.parse(toolInput) : toolInput;
          detail = toolInfo.getDetail(parsed);
        } catch {}
      }

      showActivityIndicator(toolInfo.action, detail);
    }

    function removeToolIndicator() {
      removeActivityIndicator();
    }

    function showThinkingIndicator() {
      removeThinkingIndicator();
      removeActivityIndicator();
      const indicator = document.createElement('div');
      indicator.className = 'thinking-indicator';
      indicator.innerHTML = `
        <div class="thinking-dots">
          <span></span><span></span><span></span>
        </div>
        <span class="thinking-text">Claude is thinking...</span>
      `;
      messagesEl.appendChild(indicator);
      scrollToBottom();
    }

    function removeThinkingIndicator() {
      const indicator = messagesEl.querySelector('.thinking-indicator');
      if (indicator) indicator.remove();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function scrollToBottom() {
      requestAnimationFrame(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    }

    function send() {
      const text = inputEl.value.trim();
      const hasImage = pendingImage !== null;

      // Need either text or image to send
      if ((!text && !hasImage) || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Build message payload
      const payload = { type: 'user', content: text };
      if (hasImage) {
        payload.imageId = pendingImage.id;
        payload.imageFilename = pendingImage.filename;
        payload.imageMediaType = pendingImage.mediaType;
      }

      // Reset assistant state before adding user message to ensure clean ordering
      currentAssistantMessage = null;
      assistantContent = '';

      addUserMessage(text, hasImage ? pendingImage.localUrl : null);
      ws.send(JSON.stringify(payload));
      showThinkingIndicator();

      // Clear input and image
      inputEl.value = '';
      inputEl.style.height = 'auto';
      clearPendingImage();

      // Blur to dismiss keyboard on mobile
      inputEl.blur();
    }

    function clearPendingImage() {
      if (pendingImage?.localUrl) {
        URL.revokeObjectURL(pendingImage.localUrl);
      }
      pendingImage = null;
      imagePreview.classList.remove('has-image');
      imagePreviewImg.src = '';
      imagePreviewName.textContent = '';
    }

    // Resize image if too large (max 2048px on longest side)
    async function resizeImage(file, maxSize = 2048) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          let { width, height } = img;

          // If image is small enough, return original
          if (width <= maxSize && height <= maxSize) {
            resolve(file);
            return;
          }

          // Calculate new dimensions
          if (width > height) {
            height = Math.round((height * maxSize) / width);
            width = maxSize;
          } else {
            width = Math.round((width * maxSize) / height);
            height = maxSize;
          }

          // Draw to canvas and export
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          canvas.toBlob((blob) => {
            resolve(new File([blob], file.name, { type: 'image/jpeg' }));
          }, 'image/jpeg', 0.85);
        };
        img.src = URL.createObjectURL(file);
      });
    }

    async function uploadImage(file) {
      if (!currentSession) return;

      // Resize if needed
      const resizedFile = await resizeImage(file);

      const formData = new FormData();
      formData.append('file', resizedFile);

      try {
        const res = await fetch(`/api/upload?session=${currentSession.id}`, {
          method: 'POST',
          body: formData,
        });

        if (!res.ok) {
          throw new Error(await res.text());
        }

        const data = await res.json();

        // Create local URL for preview
        const localUrl = URL.createObjectURL(file);

        pendingImage = {
          id: data.id,
          filename: data.filename,
          mediaType: data.mediaType,
          url: data.url,
          localUrl,
        };

        // Show preview
        imagePreviewImg.src = localUrl;
        imagePreviewName.textContent = file.name;
        imagePreview.classList.add('has-image');
      } catch (err) {
        console.error('Upload failed:', err);
        alert('Failed to upload image');
      }
    }

    // Title editing
    function startEditingTitle() {
      if (!currentSession || isEditingTitle) return;
      isEditingTitle = true;
      chatTitle.classList.add('editing');
      const currentName = currentSession.name;
      chatTitle.innerHTML = `<input type="text" id="title-input" value="${escapeHtml(currentName)}">`;
      const titleInput = document.getElementById('title-input');
      titleInput.focus();
      titleInput.select();

      titleInput.addEventListener('blur', () => finishEditingTitle(titleInput.value));
      titleInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          titleInput.blur();
        } else if (e.key === 'Escape') {
          titleInput.value = currentName;
          titleInput.blur();
        }
      });
    }

    async function finishEditingTitle(newName) {
      if (!isEditingTitle) return;
      isEditingTitle = false;
      chatTitle.classList.remove('editing');

      newName = newName.trim();
      if (!newName) newName = currentSession.name;

      chatTitle.textContent = newName;

      if (newName !== currentSession.name && currentSession) {
        currentSession.name = newName;
        await fetch(`/api/sessions/${currentSession.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName }),
        });
        loadSessions();
      }
    }

    async function regenerateTitle() {
      if (!currentSession) return;
      regenerateTitleBtn.classList.add('spinning');

      try {
        const res = await fetch(`/api/sessions/${currentSession.id}/regenerate-title`, {
          method: 'POST',
        });

        if (res.ok) {
          const data = await res.json();
          currentSession.name = data.name;
          chatTitle.textContent = data.name;
          loadSessions();
          messageCountSinceLastTitleUpdate = 0;
        }
      } catch (err) {
        console.error('Failed to regenerate title:', err);
      } finally {
        regenerateTitleBtn.classList.remove('spinning');
      }
    }

    // Auto-regenerate title periodically (every 6 assistant messages)
    function maybeAutoRegenerateTitle() {
      messageCountSinceLastTitleUpdate++;
      if (messageCountSinceLastTitleUpdate >= 6 && currentSession) {
        regenerateTitle();
      }
    }

    chatTitle.addEventListener('click', (e) => {
      if (currentSession && !isEditingTitle) {
        startEditingTitle();
      }
    });

    regenerateTitleBtn.addEventListener('click', regenerateTitle);

    // Event listeners
    inputEl.addEventListener('input', () => {
      inputEl.style.height = 'auto';
      inputEl.style.height = Math.min(inputEl.scrollHeight, 120) + 'px';
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    sendBtn.addEventListener('click', send);
    newChatBtn.addEventListener('click', () => createSession());
    startChatBtn.addEventListener('click', () => createSession());

    // Image upload handlers
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) {
        uploadImage(file);
      }
      fileInput.value = ''; // Reset so same file can be selected again
    });
    removeImageBtn.addEventListener('click', clearPendingImage);

    // Prevent zoom on double-tap
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, false);

    // Make deleteSession global for onclick
    window.deleteSession = deleteSession;

    // Sprites management
    function openSpritesModal() {
      loadSprites();
      spritesModal.classList.add('open');
    }

    function closeSpritesModalFn() {
      spritesModal.classList.remove('open');
      spriteNameInput.value = '';
      spriteAddressInput.value = '';
    }

    async function loadSprites() {
      const res = await fetch('/api/sprites');
      sprites = await res.json();
      renderSpritesList();
    }

    function getCurrentSpriteAddress() {
      // Get current host without port
      return location.hostname;
    }

    // Update the current sprite's publicUrl in the sprites list
    async function updateCurrentSpritePublicUrl(publicUrl) {
      if (!publicUrl) return;

      const currentAddr = getCurrentSpriteAddress();
      const sprite = sprites.find(s => s.address === currentAddr);

      if (sprite && sprite.publicUrl !== publicUrl) {
        // Update the sprite's publicUrl
        try {
          await fetch(`/api/sprites/${sprite.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ publicUrl }),
          });
          sprite.publicUrl = publicUrl;
          console.log(`Updated sprite ${sprite.name} publicUrl to ${publicUrl}`);
        } catch (err) {
          console.log('Failed to update sprite publicUrl:', err);
        }
      }
    }

    function renderSpritesList() {
      const currentAddr = getCurrentSpriteAddress();

      if (sprites.length === 0) {
        spritesList.innerHTML = '<div class="sprites-empty">No sprites saved yet. Add one below!</div>';
        return;
      }

      spritesList.innerHTML = sprites.map(s => {
        const isCurrent = s.address === currentAddr;
        return `
          <div class="sprite-item ${isCurrent ? 'current' : ''}" data-id="${s.id}" data-address="${s.address}" data-port="${s.port}" data-publicurl="${escapeHtml(s.publicUrl || '')}">
            <div class="sprite-info">
              <div class="sprite-name">
                ${escapeHtml(s.name)}
                ${isCurrent ? '<span class="sprite-current-badge">Current</span>' : ''}
              </div>
              <div class="sprite-address">${escapeHtml(s.address)}:${s.port}</div>
            </div>
            <button class="sprite-delete" onclick="deleteSprite('${s.id}', event)">Ã—</button>
          </div>
        `;
      }).join('');

      spritesList.querySelectorAll('.sprite-item').forEach(el => {
        el.addEventListener('click', (e) => {
          if (e.target.classList.contains('sprite-delete')) return;
          const address = el.dataset.address;
          const port = el.dataset.port;
          const publicUrl = el.dataset.publicurl || '';
          navigateToSprite(address, port, publicUrl);
        });
      });
    }

    async function addSprite() {
      const name = spriteNameInput.value.trim();
      const address = spriteAddressInput.value.trim();

      if (!name || !address) {
        alert('Please enter both name and address');
        return;
      }

      await fetch('/api/sprites', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, address, port: 8080 }),
      });

      spriteNameInput.value = '';
      spriteAddressInput.value = '';
      loadSprites();
    }

    async function deleteSprite(id, e) {
      e.stopPropagation();
      if (!confirm('Delete this sprite?')) return;
      await fetch(`/api/sprites/${id}`, { method: 'DELETE' });
      loadSprites();
    }

    async function navigateToSprite(address, port, publicUrl) {
      const protocol = location.protocol;
      const targetUrl = `${protocol}//${address}:${port}`;

      // If we have a publicUrl, try to wake the sprite first
      if (publicUrl) {
        // Show switching overlay
        const switchingText = switchingOverlay.querySelector('.switching-text');
        const switchingSubtext = switchingOverlay.querySelector('.switching-subtext');
        if (switchingText) switchingText.textContent = 'Switching to sprite...';
        if (switchingSubtext) switchingSubtext.textContent = 'Waking up the target sprite';
        switchingOverlay.classList.add('visible');

        // Close the sprites modal
        closeSpritesModalFn();

        // Ping the public URL to wake the sprite
        console.log('Waking sprite via publicUrl:', publicUrl);
        try {
          await fetch(publicUrl, { mode: 'no-cors', cache: 'no-store' });
        } catch (err) {
          // Expected with no-cors
        }

        // Wait for sprite to respond (try pinging the direct address)
        if (switchingSubtext) switchingSubtext.textContent = 'Waiting for sprite to respond...';

        let spriteReady = false;
        for (let i = 0; i < 15; i++) {
          try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);
            const res = await fetch(`${targetUrl}/api/config`, {
              signal: controller.signal,
              cache: 'no-store'
            });
            clearTimeout(timeout);
            if (res.ok) {
              spriteReady = true;
              break;
            }
          } catch (err) {
            // Keep trying
          }
          if (switchingSubtext) switchingSubtext.textContent = `Waiting for sprite... (${i + 1}/15)`;
          await new Promise(r => setTimeout(r, 1000));
        }

        if (spriteReady) {
          if (switchingSubtext) switchingSubtext.textContent = 'Sprite ready, navigating...';
        } else {
          if (switchingSubtext) switchingSubtext.textContent = 'Navigating anyway...';
        }

        // Small delay for visual feedback
        await new Promise(r => setTimeout(r, 300));
      }

      window.location.href = targetUrl;
    }

    // Make deleteSprite global for onclick
    window.deleteSprite = deleteSprite;

    // Sprites modal event listeners
    settingsBtn.addEventListener('click', openSpritesModal);
    closeSpritesModal.addEventListener('click', closeSpritesModalFn);
    spritesModal.addEventListener('click', (e) => {
      if (e.target === spritesModal) closeSpritesModalFn();
    });
    addSpriteBtn.addEventListener('click', addSprite);
    spriteAddressInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') addSprite();
    });

    // Pull to refresh
    let pullStartY = 0;
    let isPulling = false;
    let pullDistance = 0;
    let pullStartedOnHeader = false;
    const PULL_THRESHOLD = 80;
    const headerEl = document.querySelector('header');

    function canPullRefresh(fromHeader = false) {
      // Only allow pull refresh when sidebar/modal are closed
      if (sidebar.classList.contains('open')) return false;
      if (spritesModal.classList.contains('open')) return false;

      // If started on header, always allow
      if (fromHeader || pullStartedOnHeader) return true;

      // Check if messages area is at top or we're in empty state
      if (messagesEl.classList.contains('active')) {
        return messagesEl.scrollTop <= 0;
      }
      return true; // Empty state, always allow
    }

    document.addEventListener('touchstart', (e) => {
      // Check if touch started on header
      pullStartedOnHeader = headerEl && headerEl.contains(e.target);

      if (!canPullRefresh(pullStartedOnHeader)) return;
      pullStartY = e.touches[0].clientY;
      isPulling = true;
      pullDistance = 0;
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
      if (!isPulling || !canPullRefresh()) return;

      const currentY = e.touches[0].clientY;
      pullDistance = currentY - pullStartY;

      // Only show indicator when pulling down
      if (pullDistance > 0) {
        // Calculate indicator position (max 80px down)
        const progress = Math.min(pullDistance / PULL_THRESHOLD, 1);
        const translateY = -60 + (progress * 80);

        pullIndicator.style.transform = `translateX(-50%) translateY(${translateY}px)`;
        pullIndicator.style.transition = 'none';
        pullIndicator.classList.add('visible');

        if (pullDistance >= PULL_THRESHOLD) {
          pullIndicator.classList.add('ready');
        } else {
          pullIndicator.classList.remove('ready');
        }
      } else {
        pullIndicator.classList.remove('visible', 'ready');
      }
    }, { passive: true });

    document.addEventListener('touchend', () => {
      if (!isPulling) return;
      isPulling = false;
      pullStartedOnHeader = false;

      pullIndicator.style.transition = '';

      if (pullDistance >= PULL_THRESHOLD) {
        // Trigger refresh
        pullIndicator.classList.remove('ready');
        pullIndicator.classList.add('refreshing');

        // Save current session before reload
        if (currentSession) {
          localStorage.setItem('lastSessionId', currentSession.id);
        }

        // Small delay for visual feedback, then reload
        setTimeout(() => {
          window.location.reload();
        }, 300);
      } else {
        // Reset indicator
        pullIndicator.classList.remove('visible', 'ready');
        pullIndicator.style.transform = '';
      }

      pullDistance = 0;
    }, { passive: true });

    // Init - wake up sprite first, then load sessions
    async function init() {
      // Try to wake up the sprite (uses cached public URL if available)
      const spriteAwake = await wakeUpSprite();

      if (!spriteAwake) {
        // Sprite couldn't be reached - show error in overlay
        const wakingText = wakingOverlay.querySelector('.waking-text');
        const wakingSubtext = wakingOverlay.querySelector('.waking-subtext');
        if (wakingText) wakingText.textContent = 'Could not reach sprite';
        if (wakingSubtext) wakingSubtext.textContent = 'Check your connection and try again';

        // Keep trying in background
        setTimeout(init, 5000);
        return;
      }

      // Sprite is awake - hide overlay and load app
      hideWakingOverlay();

      // Refresh service worker cache while we have network access
      if (navigator.serviceWorker?.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'REFRESH_CACHE' });
      }

      // Start keepalive WebSocket now that sprite is awake
      connectKeepalive();

      // Load sprites list and update current sprite's publicUrl
      await loadSprites();
      if (spritePublicUrl) {
        await updateCurrentSpritePublicUrl(spritePublicUrl);
      }

      // Now load sessions and restore state
      await loadSessions();

      // Restore last session if saved (e.g., after pull-to-refresh)
      const lastSessionId = localStorage.getItem('lastSessionId');
      if (lastSessionId) {
        localStorage.removeItem('lastSessionId');
        const session = sessions.find(s => s.id === lastSessionId);
        if (session) {
          selectSession(session);
        }
      }
    }

    init();
  </script>
</body>
</html>
